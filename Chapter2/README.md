# 练习

## 2.1-1

> 以图2-2为模型，说明INSERTION-SORT在数组A=<31, 41, 59, 26, 41, 58>上的执行过程。

![InsertionSort.svg](https://github.com/shuaitq/IntroductionToAlgorithms/blob/master/Chapter2/InsertionSort.svg)

## 2.1-2

> 重写过程INSERTION-SORT，使之按非升序（而不是降序）排序。

```
INSERTION-SORT(A)
    for j = 2 to A.length
        key = A[j]
        i = j - 1
        while i > 0 and A[i] < key
            A[i + 1] = A[i]
            i = i - 1
        A[i + 1] = key
```

## 2.1-3

> 考察以下查找问题：  
> 输入：n个数的一个序列A=<a1, a2, ..., an>和一个值v。  
> 输出：下标i使得v=A[i]或者当v不在A中出现时，v为特殊值NIL。  
> 写出线性查找的伪代码，它扫描整个序列来查找v。使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要性质。

```
SEARCH(A, v)
    for i = 1 to A.length
        if v == A[i]
            return i
    return NIL
```

循环不变式：每一次循环迭代开始的时候，A[1..i-1]不包含v

初始化：i = 1时，因为A[1..0]中不包含任何一个元素，所以不包含v，循环不变式成立。  
保持：A[1..i-1]已经不包含v，如果A[i]是v那么就不会进入下一次循环，如果A[i]不是v，那么就保证了A[1..i]都不包含v，循环不变式成立。  
终止：当结束的时候j > A.length，因为每次一加一，所以j = A.length + 1，所以A[1..A.length]都证明没有包含v，返回NIL。

## 2.1-4

> 考虑把两个n位二进制整数加起来的问题，这两个整数分别存储在两个n元数组A和B中。这两个整数的和应按二进制形式存储在一个(n + 1)元数组C中。请给出该问题的形式化描述，并写出伪代码。

输入：n个0或者1的一个序列A=<a1, a2, ..., an>和另外一个同样n个0或者1的一个序列B=<a1, a2, ..., an>。
输出：一个0或者1的序列C，C所表示的数为A、B所表示数的和。

```
ADD(A, B)
    let C[1..A.length + 1] be new arrays
    carry = 0
    for i = 1 to A.length
        C[i] = (A[i] + B[i] + carry) % 2
        carry = (A[i] + B[i] + carry) / 2
    C[A.length + 1] = carry
    return C
```

# 练习

## 2.2-1

> 用O记号表示函数$n^{3}/1000-100n^{2}-100n+3$。

O($n^{3}$)

## 2.2-2

> 考虑排序存储在数组A中的n个数：首先找出A中的最小元素并将其与A[1]中的元素进行交换。接着，找出A中的次最小元素并将其与A[2]的元素进行交换。对A中前n-1个元素按该方式继续。该算法称为选择算法，写出其伪代码。该算法维持的循环不变式是什么？为什么它只需要对前n-1个元素，而不是对所有n个元素运行？用O记号给出选择排序的最好情况与最坏情况运行时间。

```
SELECTION-SORT(A)
    for i = 1 to A.legnth - 1
        min = i
        for j = i + 1 to A.length
            if A[j] < A[min]
                min = j
        temp = A[i]
        A[i] = A[min]
        A[min] = temp
```

循环不变式：每次循环迭代开始的时候，A[1..i-1]是排序好的，且A[i..A.length]不存在任何一个元素比A[1..i-1]中的更小，即A[1..i-1]就是排序结果的1..i-1部分。

因为当对前n - 1个元素运行完之后，第n个元素必定就是最大的元素，那么当前n - 1已经排序好的元素加上最大的元素在最后，那么这个序列就已经排序好了。

最好情况：序列已经是排序好的，所以min = j将永远得不到执行，所有的操作次数为$(n - 1) * (n + 5) = n^2 + 4n - 5$，所以为O($n^2$)。  
最坏情况：序列是逆序的，那么每次都会运行到min = j，所有的操作次数为$(n - 1) * (1.5n +５)　＝ 1.5n^2 + 3.5n - 5$，所以为O($n^2$)。

## 2.2-3

> 再次考虑线性查找问题（参见练习2.1-3）.假定要查找的元素等可能地为数组中的任意元素，平均需要检查输入序列的多少元素？最坏情况又如何呢？用O记号给出线性查找的平均情况和最坏情况运行时间。证明你的答案。

平均情况：需要检查元素的个数为1..n的概率都为$\frac{1}{n}$，所以平均需要查找$1\cdot\frac{1}{n} + 2\cdot\frac{1}{n} \cdots n\cdot\frac{1}{n} = \frac{1+n}{2}$，所以为O(n)。  
最坏情况：需要检查的元素为n个，所以也为O(n)。

## 2.2-4

> 应如何修改任何一个算法，才能使之具有良好的最好情况运行时间？

在运行算法之前检查一遍输入，看输入是否满足最好情况，如果是最好情况就直接返回结果。

# 练习

## 2.3-1

