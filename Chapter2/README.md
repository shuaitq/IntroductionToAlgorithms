# 练习

## 2.1-1

> 以图2-2为模型，说明INSERTION-SORT在数组A=<31, 41, 59, 26, 41, 58>上的执行过程。

![InsertionSort.svg](https://github.com/shuaitq/IntroductionToAlgorithms/blob/master/Chapter2/InsertionSort.svg)

## 2.1-2

> 重写过程INSERTION-SORT，使之按非升序（而不是降序）排序。

```
INSERTION-SORT(A)
    for j = 2 to A.length
        key = A[j]
        i = j - 1
        while i > 0 and A[i] < key
            A[i + 1] = A[i]
            i = i - 1
        A[i + 1] = key
```

## 2.1-3

> 考察以下查找问题：  
> 输入：n个数的一个序列A=<a1, a2, ..., an>和一个值v。  
> 输出：下标i使得v=A[i]或者当v不在A中出现时，v为特殊值NIL。  
> 写出线性查找的伪代码，它扫描整个序列来查找v。使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要性质。

```
SEARCH(A, v)
    for i = 1 to A.length
        if v == A[i]
            return i
    return NIL
```

循环不变式：每一次循环迭代开始的时候，A[1..i-1]不包含v

初始化：i = 1时，因为A[1..0]中不包含任何一个元素，所以不包含v，循环不变式成立。  
保持：A[1..i-1]已经不包含v，如果A[i]是v那么就不会进入下一次循环，如果A[i]不是v，那么就保证了A[1..i]都不包含v，循环不变式成立。  
终止：当结束的时候j > A.length，因为每次一加一，所以j = A.length + 1，所以A[1..A.length]都证明没有包含v，返回NIL。

## 2.1-4

> 考虑把两个n位二进制整数加起来的问题，这两个整数分别存储在两个n元数组A和B中。这两个整数的和应按二进制形式存储在一个(n + 1)元数组C中。请给出该问题的形式化描述，并写出伪代码。

输入：n个0或者1的一个序列A=<a1, a2, ..., an>和另外一个同样n个0或者1的一个序列B=<a1, a2, ..., an>。
输出：一个0或者1的序列C，C所表示的数为A、B所表示数的和。

```
ADD(A, B)
    let C[1..A.length + 1] be new arrays
    carry = 0
    for i = 1 to A.length
        C[i] = (A[i] + B[i] + carry) % 2
        carry = (A[i] + B[i] + carry) / 2
    C[A.length + 1] = carry
    return C
```

# 练习

## 2.2-1

> 用O记号表示函数$n^{3}/1000-100n^{2}-100n+3$。

O($n^{3}$)

## 2.2-2

> 考虑排序存储在数组A中的n个数：首先找出A中的最小元素并将其与A[1]中的元素进行交换。接着，找出A中的次最小元素并将其与A[2]的元素进行交换。对A中前n-1个元素按该方式继续。该算法称为选择算法，写出其伪代码。该算法维持的循环不变式是什么？为什么它只需要对前n-1个元素，而不是对所有n个元素运行？用O记号给出选择排序的最好情况与最坏情况运行时间。

```
SELECTION-SORT(A)
    for i = 1 to A.legnth - 1
        min = i
        for j = i + 1 to A.length
            if A[j] < A[min]
                min = j
        temp = A[i]
        A[i] = A[min]
        A[min] = temp
```

循环不变式：每次循环迭代开始的时候，A[1..i-1]是排序好的，且A[i..A.length]不存在任何一个元素比A[1..i-1]中的更小，即A[1..i-1]就是排序结果的1..i-1部分。

因为当对前n - 1个元素运行完之后，第n个元素必定就是最大的元素，那么当前n - 1已经排序好的元素加上最大的元素在最后，那么这个序列就已经排序好了。

最好情况：序列已经是排序好的，所以min = j将永远得不到执行，所有的操作次数为$(n - 1) * (n + 5) = n^2 + 4n - 5$，所以为O($n^2$)。  
最坏情况：序列是逆序的，那么每次都会运行到min = j，所有的操作次数为$(n - 1) * (1.5n +５)　＝ 1.5n^2 + 3.5n - 5$，所以为O($n^2$)。

## 2.2-3

> 再次考虑线性查找问题（参见练习2.1-3）.假定要查找的元素等可能地为数组中的任意元素，平均需要检查输入序列的多少元素？最坏情况又如何呢？用O记号给出线性查找的平均情况和最坏情况运行时间。证明你的答案。

平均情况：需要检查元素的个数为1..n的概率都为$\frac{1}{n}$，所以平均需要查找$1\cdot\frac{1}{n} + 2\cdot\frac{1}{n} \cdots n\cdot\frac{1}{n} = \frac{1+n}{2}$，所以为O(n)。  
最坏情况：需要检查的元素为n个，所以也为O(n)。

## 2.2-4

> 应如何修改任何一个算法，才能使之具有良好的最好情况运行时间？

在运行算法之前检查一遍输入，看输入是否满足最好情况，如果是最好情况就直接返回结果。

# 练习

## 2.3-1

> 使用图2-4作为模型，说明归并排序在数组A=<3, 41, 52, 26, 38, 57, 9, 49>上的操作。

![MergeSort.svg](https://github.com/shuaitq/IntroductionToAlgorithms/blob/master/Chapter2/MergeSort.svg)

## 2.3-2

> 重写过程MERGE，使之不适用哨兵，而是一旦数组L或者R的所有元素均被复制回A就立刻停止，然后把另外一个数组的剩余部分复制回A。

```
MERGE(A, p, q, r)
    n1 = q - p + 1
    n2 = r - q
    let L[1..n1] and R[1..n2] be new arrays
    for i = 1 to n1
        L[i] = A[p + i - 1]
    for i = 1 to n2
        R[i] = A[q + i]
    i = 1
    j = 1
    k = p
    while i <= n1 and j <= n2
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else
            A[k] = R[j]
            j = j + 1
        k = k + 1
    while i <= n1
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j <= n2
        A[k] = R[j]
        j = j + 1
        k = k + 1
```

## 2.3-3

> 使用数学证明归纳法证明：当n正好是2的幂时，以下递归式的解是$T(n) = n\lg{n}$。

$$
T(n) = \begin{cases}
2 & \text{ if } n=2 \\ 
2T(n/2)+n & \text{ if } n=2^{k},k>1 
\end{cases}
$$

当$n=2$时，$T(n) = 2 = 2 \cdot lg{2}$，满足$T(n) = n\lg{n}$。  
假设当$n=2^{k}$时，满足$T(n) = n\lg{n}$，当$n = 2^{k+1}$时，$T(n) = 2 \cdot n/2\lg{n/2} + n = n\lg{n/2} + n = n\lg{n} - n + n = n\lg{n}$ 。  
综上所述：递归式的解为$T(n) = n\lg{n}$ 

## 2.3-4

> 我们可以把插入排序表示为如下的一个递归过程。为了排序A[1..n]，我们递归地排列A[1..n - 1]，然后把A[n]插入已排序的数组A[1..n - 1].为插入排序的这个递归版本的最坏情况运行时间写一个递归式。

$$
T(n) = \begin{cases}
1 & \text{ if } n=1 \\ 
T(n - 1) + n - 1 & otherwise
\end{cases}
$$

## 2.3-5

> 回顾查找问题（参见练习2.1-3），注意到，如果序列A已排好序，就可以将该序列的中点与v进行比较。根据比较结果，原序列中有一半就可以不用再做进一步的考虑了。二分查找算法重复这个过程，每次都将序列剩余部分的规模减半。为二分查找写出迭代或递归的伪代码。证明：二分查找的最坏情况运行时间为$O(\lg{n})$。

```
BINARY-SEARCH(A, v)
    low = 1
    high = A.length

    while low <= high
        mid = (low + high) / 2
        if A[mid] == v
            return mid
        else if A[mid] < v
            low = mid + 1
        else
            high = mid - 1

    return NIL
```

可以发现

$$
T(n) = \begin{cases}
1 & \text{ if } n=1 \\ 
T(n / 2) + 1 & otherwise
\end{cases}
$$

因为递归树最高$\lg{n}$层，每一层代价为1，所以最坏情况运行时间为$O(\lg{n})$。

## 2.3-6

> 注意到2.1节中的过程INSERTION-SORT的第5~7行的while循环采用一种线性查找来（反向）扫描已排好序的子数组A[1..j-1]。我们可以使用二分查找（参见练习2.3-5）来吧插入排序的最坏情况总运行时间改进到$O(n\lg{n})$吗？

不行，因为虽然查找时间变为了$O(\lg{n})$，但是你在查找到位置之后还是需要用$O(n)$的时间去把元素移到位置并把后面的元素往后移，这样最坏情况总运行时间还是$O(n^{2})$。

## 2.3-7

> 描述一个运行时间为$O(n\lg{n})$的算法，给定n个整数的集合S和另一个整数x，该算法能确定S中是否存在两个其和刚好为x的元素。

先使用一个$O(n\lg{n})$复杂度的排序算法对S从低到高排序，然后使用两个迭代器分别从两端遍历，如果两个数字加起来大于x就将大的迭代器减一，如果小于就将小的迭代器加一，如果等于就返回存在，如果两个迭代器相遇就返回不存在。因为总的复杂度为$O(n\lg{n} + n)=O(n\lg{n})$所以满足要求。

```
PAIR-EXISTS(S, x)
    MERGE-SORT(S, 1, S.length)
    low = 1
    high = S.length

    while low < high
        if S[low] + S[high] > x
            high = high - 1
        else if S[low] + S[high] < x
            low = low + 1
        else
            return true
    
    return false
```

# 思考题

## 2-1

> （在归并排序中对小数组采用插入排序）虽然归并排序的最坏情况运行时间为$O(n\lg{n})$，而插入排序的最坏情况运行时间为$O(n^{2})$，但是插入排序中的常量因子可能使得它在n较小时，在许多机器上实际运行得更快。因此，在归并排序中当子问题变得足够小时，采用插入排序来使递归的叶变粗是有意义的。考虑对归并排序的一种修改，其中使用插入排序来排序长度为k的n/k个子表，然后使用标准的合并机制来合并这些子表，这里k是一个待定的值。  
> a.证明：插入排序最坏情况可以在O(nk)时间内排序每个长度为k的n/k个子表。

对于每个长度为k的子表插入排序复杂度为$O(k^2)$，总共有n/k个子表，总的复杂度为$O(k^2 \cdot n/k) = O(nk)$，证毕。

> b.表明在最坏情况下如何在$O(n\lg{n/k})$时间内合并这些子表。

因为总共有n/k个子表，我们以归并排序的方式两个两个分别合并这些子表，所以递归树的高度为$\lg{n/k}$层，每一层需要合并的元素个数都为n个，所以我们可以在最坏情况下在$O(n\lg{n/k})$时间内合并这些子表。

> c.假定修改后的算法的最坏情况运行时间为$O(nk + n\lg(n/k))$，要使修改后的算法与标准的归并排序具有相同的运行时间，作为n的一个函数，借助O记号，k的最大值是什么？

k的最大值为$\lg{n}$，因为如果$k=f(n) > \lg{n}$那么nk作为主体的复杂度$nf(n) > n\lg{n}$，这样的话比归并排序就会更慢了。

> d.在实践中我们应该如何选择k？

我们可以通过大量测试选择出适合多数机器的k值作为常量。

## 2-2

> （冒泡排序正确性）冒泡排序是一种流行但低效的排序算法，它的作用是反复交换相邻的未按次序排列的元素。

```
BUBBLESORT(A)
    for i = 1 to A.length - 1
        for j = A.length downto i + 1
            if A[j] < A[j - 1]
                exchange A[j] with A[j - 1]
```

> a.假设A'表示BUBBLESORT(A)的输出。为了证明BUBBLESORT正确，我们必须证明它将终止并且有：

$$
A'[1] \leq A'[2] \leq \cdots \leq A'[n]
$$

> 其中n=A.length。为了证明BUBBLESORT确实完成了排序，我们还需要证明什么？下面两部分将证明不等式(2.3)

我们还需要证明其中的所有元素和之前A中元素相同

> b.为第2~4行的for循环精确地说明一个循环不变式，并证明该循环不变式成立。你的证明应该使用本章中给出的循环不变式证明的结构。

循环不变式：A[j - 1]是A[j - 1..A.length]中最小的

初始化：当j = A.length的时候，对比A[j]和A[j - 1]，将小的放到A[j - 1]中，保证了循环不变式。  
保持：已知当A[j]是A[j..A.length]中最小的时候，进入下一次迭代，我们会对比A[j]和A[j - 1]，将小的放入A[j - 1]中，因为A[j]已经是A[j..A.length]中最小的元素了，所以本次迭代后，A[j - 1]将会是A[j - 1..A.length]中最小的，保持了循环不变性。  
终止：当j = i时终止，保证了A[i]是A[i..A.length]中最小的元素。

> c.使用(b)部分证明的循环不变式的终止条件，为第1~4行的for循环说明一个循环不变式，该不变式将使你能证明不等式(2.3).你的证明应该使用本章中给出的循环不变式的证明结构。

循环不变式：A[1..i]为A[1..A.length]中最小且排序好的i个元素。

初始化：当i = 1时，通过b可知，A[1]会变成A[1..A.length]中最小的元素，满足循环不变性。  
保持：因为A[i]已经是A[1..A.length]第i大的元素了，所以当运行i + 1次时，A[i + 1] >= A[i]并且A[i + 1]为第i + 1大的元素，保证了循环不变性。  
终止：i = A.length时结束，保证了A[1..A.length - 1]为A[1..A.length]中最小的且排好序的A.length - 1个元素，那么A[A.length]必然时A[1..A.length]中最大的元素，并自动满足了A[1..A.length]是A[1..A.length]中最小且排序好的A.length个元素，满足循环不变性。

> d.冒泡排序的最坏情况运行时间是多少？与插入排序的运行时间相比，其性能如何？

冒泡排序最坏运行时间为$n - 1 + n - 2 + \cdots + 1 = \frac{n \cdot (n - 1)}{2}$，时间复杂度为$O(n^{2})$。与插入排序相比，两者最好的时间复杂度都为O(n)而最差复杂度都为$O(n^{2})$，只有常数级的差距。

## 2-3

> （霍纳(Horner)规则的正确性）给定系数a0, a1, ..., an和x的值，代码片段

```
y = 0
for i = n downto 0
    y = ai + x * y
```

> 实现了用于求值多项式

$$
P(x) = \sum_{k=0}^{n} a_{k}x^{k} = a_{0} + x(a_{1} + x(a_{2} + \cdots + x(a_{n-1} + xa_{n}) \cdots ))
$$

> 的霍纳规则。

> a.借助O记号，实现霍纳规则的以上代码片段的运行时间是多少？

时间复杂度为O(n)。

> b.编写伪代码来实现朴素的多项式求值算法，该算法从头开始计算多项式的每一个项。该算法的运行时间是多少？与霍纳规则相比，其性能如何？

```
y = 0
for i = 0 to n
    b = ai
    for j = 1 to i
        b = b * x
    y = y + b
```

算法时间复杂度为$O(n^2)$。与霍纳规则相比，其性能没有霍纳规则好。

> d.考虑以下循环不变式：  
> 在第2~3行for循环每次迭代的开始有

$$
y = \sum_{k=0}^{n - (i + 1)} a_{k + i + 1}x^{k}
$$

> 把没有项的和式解释为等于0。遵照本章中给出的循环不变式证明的结构，使用该循环不变式来证明终止时有$y = \sum_{k=0}^{n} a_{k}x^{k}$。

初始化：i = n时和式没有项，所以等于0，符合y = 0，满足循环不变式。  
保持：当第i次迭代结束的时候。

$$
y = a_{i} + x \sum_{k=0}^{n - (i + 1)} a_{k + i + 1}x^{k} = a_{i}x^{0} + \sum_{k=0}^{n - (i + 1)} a_{k + i + 1}x^{k + 1} = \sum_{k=0}^{n - i} a_{k + i}x^{k}
$$

终止：结束时i = -1带入式子我们可以证得$y = \sum_{k=0}^{n} a_{k}x^{k}$。

> d.最后证明上面给出的代码片段将正确地求由系数a0, a1, ..., an刻画的多项式的值。

我们可以根据c中的证明得出上述代码能够给出正确的多项式的值。

## 2-4

> （逆序对）假设A[1..n]是一个有n个不同数的数组。若i<j且A[i]>A[j]，则对偶(i, j)称为A的一个逆序对(inversion)。

> a.列出数组<2, 3, 8, 6, 1>的5个逆序对。

(1, 5) (2, 5) (3, 4) (3, 5) (4, 5)

> b.由集合{1, 2, ..., n}中元素构成的什么数组具有最多的逆序对？它有多少逆序对？

数组<n, n - 1, ..., 1>具有最多的逆序对，因为每一个数都和它之前的所有数形成逆序对。

$$
(n - 1) + (n - 2) + \cdots + 1 = \frac{n \cdot (n - 1)}{2}
$$

> c.插入排序的运行时间与输入数组中的逆序对的数量之间是什么关系？证明你的回答。

插入排序的运行时间与输入数组中逆序对的数量成常量比例关系，因为对于每一个元素，使用插入排序算法过程中需要跳过的比它大的元素都与它成逆序对，而且不会有漏下的逆序对，所以插入排序的交换次数就是输入数组中逆序对的数量，所以它们之间成常数比例关系。

> d.给出一个确定在n个元素的任何排列中逆序对数量的算法，最坏情况需要$O(n\lg{n})$时间。（提示：修改归并排序。）

在归并排序的归并的部分加入一个计算即可。首先对于归并排序的最小分割，即一个元素的数组，它不存在逆序对，所以我们不需要处理。在归并部分，我们有左右两个已经排序好的数组，当我们选择出一个右边数组中的数插入到最终数组中的时候，代表着所有左边数组中的元素都大于被插入的元素，因为左边数组中元素最开始在任意一个右边数组元素的左边，所以剩余左边数组中的任意一个元素都和右边数组形成逆序对，我们只需要加上左边数组的长度即可，最后逆序对的数量就是总的和。因为我们只是在合并操作中加了一个常数级操作，所以对归并排序的复杂度没有影响，仍然是$O(n\lg{n})$。