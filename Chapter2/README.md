# 练习

## 2.1-1

> 以图2-2为模型，说明INSERTION-SORT在数组A=<31, 41, 59, 26, 41, 58>上的执行过程。

![InsertionSort.svg](https://github.com/shuaitq/IntroductionToAlgorithms/blob/master/Chapter2/InsertionSort.svg)

## 2.1-2

> 重写过程INSERTION-SORT，使之按非升序（而不是降序）排序。

```
INSERTION-SORT(A)
    for j = 2 to A.length
        key = A[j]
        i = j - 1
        while i > 0 and A[i] < key
            A[i + 1] = A[i]
            i = i - 1
        A[i + 1] = key
```

## 2.1-3

> 考察以下查找问题：  
> 输入：n个数的一个序列A=<a1, a2, ..., an>和一个值v。  
> 输出：下标i使得v=A[i]或者当v不在A中出现时，v为特殊值NIL。  
> 写出线性查找的伪代码，它扫描整个序列来查找v。使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要性质。

```
SEARCH(A, v)
    for i = 1 to A.length
        if v == A[i]
            return i
    return NIL
```

循环不变式：每一次循环迭代开始的时候，A[1..i-1]不包含v

初始化：i = 1时，因为A[1..0]中不包含任何一个元素，所以不包含v，循环不变式成立。  
保持：A[1..i-1]已经不包含v，如果A[i]是v那么就不会进入下一次循环，如果A[i]不是v，那么就保证了A[1..i]都不包含v，循环不变式成立。  
终止：当结束的时候j > A.length，因为每次一加一，所以j = A.length + 1，所以A[1..A.length]都证明没有包含v，返回NIL。

## 2.1-4

> 考虑把两个n位二进制整数加起来的问题，这两个整数分别存储在两个n元数组A和B中。这两个整数的和应按二进制形式存储在一个(n + 1)元数组C中。请给出该问题的形式化描述，并写出伪代码。

输入：n个0或者1的一个序列A=<a1, a2, ..., an>和另外一个同样n个0或者1的一个序列B=<a1, a2, ..., an>。
输出：一个0或者1的序列C，C所表示的数为A、B所表示数的和。

```
ADD(A, B)
    let C[1..A.length + 1] be new arrays
    carry = 0
    for i = 1 to A.length
        C[i] = (A[i] + B[i] + carry) % 2
        carry = (A[i] + B[i] + carry) / 2
    C[A.length + 1] = carry
    return C
```

# 练习

## 2.2-1

> 用O记号表示函数$n^{3}/1000-100n^{2}-100n+3$。

O($n^{3}$)

## 2.2-2

> 考虑排序存储在数组A中的n个数：首先找出A中的最小元素并将其与A[1]中的元素进行交换。接着，找出A中的次最小元素并将其与A[2]的元素进行交换。对A中前n-1个元素按该方式继续。该算法称为选择算法，写出其伪代码。该算法维持的循环不变式是什么？为什么它只需要对前n-1个元素，而不是对所有n个元素运行？用O记号给出选择排序的最好情况与最坏情况运行时间。

```
SELECTION-SORT(A)
    for i = 1 to A.legnth - 1
        min = i
        for j = i + 1 to A.length
            if A[j] < A[min]
                min = j
        temp = A[i]
        A[i] = A[min]
        A[min] = temp
```

循环不变式：每次循环迭代开始的时候，A[1..i-1]是排序好的，且A[i..A.length]不存在任何一个元素比A[1..i-1]中的更小，即A[1..i-1]就是排序结果的1..i-1部分。

因为当对前n - 1个元素运行完之后，第n个元素必定就是最大的元素，那么当前n - 1已经排序好的元素加上最大的元素在最后，那么这个序列就已经排序好了。

最好情况：序列已经是排序好的，所以min = j将永远得不到执行，所有的操作次数为$(n - 1) * (n + 5) = n^2 + 4n - 5$，所以为O($n^2$)。  
最坏情况：序列是逆序的，那么每次都会运行到min = j，所有的操作次数为$(n - 1) * (1.5n +５)　＝ 1.5n^2 + 3.5n - 5$，所以为O($n^2$)。

## 2.2-3

> 再次考虑线性查找问题（参见练习2.1-3）.假定要查找的元素等可能地为数组中的任意元素，平均需要检查输入序列的多少元素？最坏情况又如何呢？用O记号给出线性查找的平均情况和最坏情况运行时间。证明你的答案。

平均情况：需要检查元素的个数为1..n的概率都为$\frac{1}{n}$，所以平均需要查找$1\cdot\frac{1}{n} + 2\cdot\frac{1}{n} \cdots n\cdot\frac{1}{n} = \frac{1+n}{2}$，所以为O(n)。  
最坏情况：需要检查的元素为n个，所以也为O(n)。

## 2.2-4

> 应如何修改任何一个算法，才能使之具有良好的最好情况运行时间？

在运行算法之前检查一遍输入，看输入是否满足最好情况，如果是最好情况就直接返回结果。

# 练习

## 2.3-1

> 使用图2-4作为模型，说明归并排序在数组A=<3, 41, 52, 26, 38, 57, 9, 49>上的操作。

![MergeSort.svg](https://github.com/shuaitq/IntroductionToAlgorithms/blob/master/Chapter2/MergeSort.svg)

## 2.3-2

> 重写过程MERGE，使之不适用哨兵，而是一旦数组L或者R的所有元素均被复制回A就立刻停止，然后把另外一个数组的剩余部分复制回A。

```
MERGE(A, p, q, r)
    n1 = q - p + 1
    n2 = r - q
    let L[1..n1] and R[1..n2] be new arrays
    for i = 1 to n1
        L[i] = A[p + i - 1]
    for i = 1 to n2
        R[i] = A[q + i]
    i = 1
    j = 1
    k = p
    while i <= n1 and j <= n2
        if L[i] <= R[j]
            A[k] = L[i]
            i = i + 1
        else
            A[k] = R[j]
            j = j + 1
        k = k + 1
    while i <= n1
        A[k] = L[i]
        i = i + 1
        k = k + 1
    while j <= n2
        A[k] = R[j]
        j = j + 1
        k = k + 1
```

## 2.3-3

> 使用数学证明归纳法证明：当n正好是2的幂时，以下递归式的解是$T(n) = n\lg{n}$。

$$
T(n) = \begin{cases}
2 & \text{ if } n=2 \\ 
2T(n/2)+n & \text{ if } n=2^{k},k>1 
\end{cases}
$$

当$n=2$时，$T(n) = 2 = 2 \cdot lg{2}$，满足$T(n) = n\lg{n}$。  
假设当$n=2^{k}$时，满足$T(n) = n\lg{n}$，当$n = 2^{k+1}$时，$T(n) = 2 \cdot n/2\lg{n/2} + n = n\lg{n/2} + n = n\lg{n} - n + n = n\lg{n}$ 。  
综上所述：递归式的解为$T(n) = n\lg{n}$ 

## 2.3-4

> 我们可以把插入排序表示为如下的一个递归过程。为了排序A[1..n]，我们递归地排列A[1..n - 1]，然后把A[n]插入已排序的数组A[1..n - 1].为插入排序的这个递归版本的最坏情况运行时间写一个递归式。

$$
T(n) = \begin{cases}
1 & \text{ if } n=1 \\ 
T(n - 1) + n - 1 & otherwise
\end{cases}
$$

## 2.3-5

> 回顾查找问题（参见练习2.1-3），注意到，如果序列A已排好序，就可以将该序列的中点与v进行比较。根据比较结果，原序列中有一半就可以不用再做进一步的考虑了。二分查找算法重复这个过程，每次都将序列剩余部分的规模减半。为二分查找写出迭代或递归的伪代码。证明：二分查找的最坏情况运行时间为$O(\lg{n})$。

```
BINARY-SEARCH(A, v)
    low = 1
    high = A.length

    while low <= high
        mid = (low + high) / 2
        if A[mid] == v
            return mid
        else if A[mid] < v
            low = mid + 1
        else
            high = mid - 1

    return NIL
```

可以发现

$$
T(n) = \begin{cases}
1 & \text{ if } n=1 \\ 
T(n / 2) + 1 & otherwise
\end{cases}
$$

因为递归树最高$\lg{n}$层，每一层代价为1，所以最坏情况运行时间为$O(\lg{n})$。

## 2.3-6

> 注意到2.1节中的过程INSERTION-SORT的第5~7行的while循环采用一种线性查找来（反向）扫描已排好序的子数组A[1..j-1]。我们可以使用二分查找（参见练习2.3-5）来吧插入排序的最坏情况总运行时间改进到$O(n\lg{n})$吗？

不行，因为虽然查找时间变为了$O(\lg{n})$，但是你在查找到位置之后还是需要用$O(n)$的时间去把元素移到位置并把后面的元素往后移，这样最坏情况总运行时间还是$O(n^{2})$。

## 2.3-7

> 描述一个运行时间为$O(n\lg{n})$的算法，给定n个整数的集合S和另一个整数x，该算法能确定S中是否存在两个其和刚好为x的元素。

先使用一个$O(n\lg{n})$复杂度的排序算法对S从低到高排序，然后使用两个迭代器分别从两端遍历，如果两个数字加起来大于x就将大的迭代器减一，如果小于就将小的迭代器加一，如果等于就返回存在，如果两个迭代器相遇就返回不存在。因为总的复杂度为$O(n\lg{n} + n)=O(n\lg{n})$所以满足要求。

```
PAIR-EXISTS(S, x)
    MERGE-SORT(S, 1, S.length)
    low = 1
    high = S.length

    while low < high
        if S[low] + S[high] > x
            high = high - 1
        else if S[low] + S[high] < x
            low = low + 1
        else
            return true
    
    return false
```

# 思考题

## 2-1

> （在归并排序中对小数组采用插入排序）虽然归并排序的最坏情况运行时间为$O(n\lg{n})$，而插入排序的最坏情况运行时间为$O(n^{2})$，但是插入排序中的常量因子可能使得它在n较小时，在许多机器上实际运行得更快。因此，在归并排序中当子问题变得足够小时，采用插入排序来使递归的叶变粗是有意义的。考虑对归并排序的一种修改，其中使用插入排序来排序长度为k的n/k个子表，然后使用标准的合并机制来合并这些子表，这里k是一个待定的值。  
> a.证明：插入排序最坏情况可以在O(nk)时间内排序每个长度为k的n/k个子表。

对于每个长度为k的子表插入排序复杂度为$O(k^2)$，总共有n/k个子表，总的复杂度为$O(k^2 \cdot n/k) = O(nk)$，证毕。

> b.表明在最坏情况下如何在$O(n\lg{n/k})$时间内合并这些子表。

因为总共有n/k个子表，我们以归并排序的方式两个两个分别合并这些子表，所以递归树的高度为$\lg{n/k}$层，每一层需要合并的元素个数都为n个，所以我们可以在最坏情况下在$O(n\lg{n/k})$时间内合并这些子表。

> c.假定修改后的算法的最坏情况运行时间为$O(nk + n\lg(n/k))$，要使修改后的算法与标准的归并排序具有相同的运行时间，作为n的一个函数，借助O记号，k的最大值是什么？

k的最大值为$\lg{n}$，因为如果$k=f(n) > \lg{n}$那么nk作为主体的复杂度$nf(n) > n\lg{n}$，这样的话比归并排序就会更慢了。

> d.在实践中我们应该如何选择k？

我们可以通过大量测试选择出适合多数机器的k值作为常量。